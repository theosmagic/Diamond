/**
 * Obsidian-Style Diamond Tree Generator
 * 
 * Concept:
 * - Each Diamond contract is a node in an Obsidian knowledge graph
 * - Links between Diamonds form the "tree" (nervous system connections)
 * - Rarity colors: Common (#FFFFFF), Magic (Blue), Rare (Yellow), Epic (Purple), Legendary (Bronze/Gold)
 * - Community rating determines rarity based on script quality and usage
 * - Diamonds can be traded
 */

import * as fs from 'fs';
import { createHash } from 'crypto';

// Rarity Colors (Obsidian theme)
const RARITY_COLORS = {
  Common: '#FFFFFF',      // White
  Magic: '#4A90E2',       // Blue
  Rare: '#FFD700',        // Yellow/Gold
  Epic: '#9B59B6',        // Purple
  Legendary: '#CD7F32'    // Bronze (can be Gold #FFD700 for highest tier)
};

// Rarity thresholds based on community rating
const RARITY_THRESHOLDS = {
  Common: { min: 0, max: 2.5 },
  Magic: { min: 2.5, max: 5.0 },
  Rare: { min: 5.0, max: 7.5 },
  Epic: { min: 7.5, max: 9.5 },
  Legendary: { min: 9.5, max: 10.0 }
};

interface DiamondNode {
  id: string;
  name: string;
  address: string;
  rarity: string;
  color: string;
  communityRating: number;
  usageCount: number;
  scriptQuality: number;
  links: string[]; // IDs of connected Diamonds
  gems: string[]; // Socketed gem addresses
  school?: string; // If it's a gem-based Diamond
  tags: string[];
  created: string;
  lastUpdated: string;
  status?: 'pending' | 'complete'; // Deployment status
  deployedNetworks?: string[]; // Networks where this Diamond is deployed
  ipfsHash?: string; // IPFS hash of Obsidian fork
  ipfsGlyph?: string; // Imperial Aramaic Glyph assigned to IPFS CID
  ipfsNode?: boolean; // Whether this CID is an IPFS node
}

// Generate Obsidian markdown for a Diamond node
function generateObsidianNode(diamond: DiamondNode): string {
  const colorTag = `#${diamond.rarity.toLowerCase()}`;
  const schoolTag = diamond.school ? `#${diamond.school.toLowerCase()}` : '';
  
  const statusBadge = diamond.status === 'complete' 
    ? '<span class="diamond-complete">âœ“ Deployed</span>' 
    : '';
  
  return `---
id: ${diamond.id}
address: ${diamond.address}
rarity: ${diamond.rarity}
color: ${diamond.color}
rating: ${diamond.communityRating.toFixed(2)}/10
usage: ${diamond.usageCount}
quality: ${diamond.scriptQuality.toFixed(2)}/10
created: ${diamond.created}
updated: ${diamond.lastUpdated}
status: ${diamond.status || 'pending'}
deployedNetworks: [${(diamond.deployedNetworks || []).join(', ')}]
ipfsHash: ${diamond.ipfsHash || 'N/A'}
tags: [${diamond.tags.join(', ')}]
---

# ${diamond.name} ${statusBadge}

**Rarity:** <span style="color: ${diamond.color}">${diamond.rarity}</span>  
**Address:** \`${diamond.address}\`  
**Community Rating:** ${diamond.communityRating.toFixed(2)}/10 â­  
**Usage Count:** ${diamond.usageCount}  
**Script Quality:** ${diamond.scriptQuality.toFixed(2)}/10

## Description

This Diamond contract acts as a neuron in the Diamond nervous system.

## Connections

${diamond.links.length > 0 ? diamond.links.map(link => `- [[${link}]]`).join('\n') : '- No connections yet'}

## Socketed Gems

${diamond.gems.length > 0 ? diamond.gems.map((gem, i) => `- Gem ${i + 1}: \`${gem}\``).join('\n') : '- No gems socketed'}

## Community Metrics

- **Rating:** ${diamond.communityRating.toFixed(2)}/10
- **Usage:** ${diamond.usageCount} times
- **Quality Score:** ${diamond.scriptQuality.toFixed(2)}/10
- **Rarity Status:** ${diamond.rarity} (determined by community)

## Deployment Status

${diamond.status === 'complete' 
  ? `âœ… **Deployed** to: ${(diamond.deployedNetworks || []).join(', ') || 'Unknown network'}`
  : 'â³ **Pending** deployment'}

${diamond.ipfsHash ? `**IPFS:** \`ipfs://${diamond.ipfsHash}\`` : ''}

${diamond.ipfsNode && diamond.ipfsGlyph 
  ? `**IPFS Node:** ${diamond.ipfsGlyph} (Imperial Aramaic Glyph)` 
  : ''}

${diamond.ipfsNode 
  ? `**Node Type:** IPFS FUSE Mount (CID = Node)` 
  : ''}

## Trading

This Diamond can be traded based on its rarity and community rating.

**Estimated Value:** Based on rarity, rating, and usage.

## Related

${diamond.links.map(link => `- [[${link}]]`).join('\n')}

---
*Generated by Diamond Tree System*
*Tags: ${colorTag} ${schoolTag} #diamond #neuron #smart-contract*
`;
}

// Generate graph visualization (Mermaid format for Obsidian)
function generateGraphVisualization(diamonds: DiamondNode[]): string {
  let mermaid = '```mermaid\ngraph TD\n';
  
  // Group by rarity for color coding
  const byRarity: Record<string, DiamondNode[]> = {};
  diamonds.forEach(d => {
    if (!byRarity[d.rarity]) byRarity[d.rarity] = [];
    byRarity[d.rarity].push(d);
  });
  
  // Create nodes with colors
  diamonds.forEach(diamond => {
    const color = diamond.color.replace('#', '');
    mermaid += `  ${diamond.id}["${diamond.name}<br/>${diamond.rarity}<br/>â­${diamond.communityRating.toFixed(1)}"]:::${diamond.rarity.toLowerCase()}\n`;
  });
  
  // Create links
  diamonds.forEach(diamond => {
    diamond.links.forEach(linkId => {
      mermaid += `  ${diamond.id} --> ${linkId}\n`;
    });
  });
  
  // Add color classes
  mermaid += '\n  classDef common fill:#FFFFFF,stroke:#000,stroke-width:2px\n';
  mermaid += '  classDef magic fill:#4A90E2,stroke:#000,stroke-width:2px,color:#fff\n';
  mermaid += '  classDef rare fill:#FFD700,stroke:#000,stroke-width:2px\n';
  mermaid += '  classDef epic fill:#9B59B6,stroke:#000,stroke-width:2px,color:#fff\n';
  mermaid += '  classDef legendary fill:#CD7F32,stroke:#000,stroke-width:3px,color:#fff\n';
  
  mermaid += '```\n';
  return mermaid;
}

// Calculate rarity based on community metrics
function calculateRarity(rating: number, usage: number, quality: number): string {
  // Combined score: 40% rating + 30% usage (normalized) + 30% quality
  const normalizedUsage = Math.min(usage / 1000, 1) * 10; // Normalize to 0-10
  const combinedScore = (rating * 0.4) + (normalizedUsage * 0.3) + (quality * 0.3);
  
  if (combinedScore >= RARITY_THRESHOLDS.Legendary.min) return 'Legendary';
  if (combinedScore >= RARITY_THRESHOLDS.Epic.min) return 'Epic';
  if (combinedScore >= RARITY_THRESHOLDS.Rare.min) return 'Rare';
  if (combinedScore >= RARITY_THRESHOLDS.Magic.min) return 'Magic';
  return 'Common';
}

// Generate Diamond nodes from existing gems and facets
function generateDiamondNodes(): DiamondNode[] {
  const diamonds: DiamondNode[] = [];
  
  // Read gem manifest if it exists
  const gemManifestPath = '/home/theos/gems/gem_manifest.json';
  let gems: any[] = [];
  
  if (fs.existsSync(gemManifestPath)) {
    const manifest = JSON.parse(fs.readFileSync(gemManifestPath, 'utf-8'));
    gems = manifest.gems || [];
  }
  
  // Generate Diamond nodes from gems (each gem can be a Diamond)
  gems.forEach((gem: any, index: number) => {
    // Simulate community metrics (in real system, these would come from on-chain data)
    const rating = Math.random() * 10; // 0-10
    const usage = Math.floor(Math.random() * 2000); // 0-2000
    const quality = Math.random() * 10; // 0-10
    
    const rarity = calculateRarity(rating, usage, quality);
    const color = RARITY_COLORS[rarity as keyof typeof RARITY_COLORS] || RARITY_COLORS.Common;
    
    // Generate connections (tree structure)
    const links: string[] = [];
    if (index > 0) {
      // Link to previous Diamond (linear tree)
      links.push(`diamond-${index - 1}`);
    }
    if (index < gems.length - 1) {
      // Link to next Diamond
      links.push(`diamond-${index + 1}`);
    }
    // Random additional connections (like a neural network)
    if (Math.random() > 0.7 && index > 10) {
      const randomLink = Math.floor(Math.random() * index);
      if (!links.includes(`diamond-${randomLink}`)) {
        links.push(`diamond-${randomLink}`);
      }
    }
    
    const diamond: DiamondNode = {
      id: `diamond-${index}`,
      name: `${gem.name} Diamond`,
      address: `0x${createHash('sha256').update(`${gem.id}-${index}`).digest('hex').substring(0, 40)}`,
      rarity,
      color,
      communityRating: rating,
      usageCount: usage,
      scriptQuality: quality,
      links,
      gems: [`gem-${gem.id}`],
      school: gem.school,
      tags: [rarity.toLowerCase(), gem.school?.toLowerCase() || 'unknown', 'diamond', 'neuron'],
      created: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
      lastUpdated: new Date().toISOString()
    };
    
    diamonds.push(diamond);
  });
  
  // Add Nervous System Diamond as central hub
  const nervousDiamond: DiamondNode = {
    id: 'nervous-system-hub',
    name: 'Nervous System Hub',
    address: '0x0000000000000000000000000000000000000000',
    rarity: 'Legendary',
    color: RARITY_COLORS.Legendary,
    communityRating: 9.8,
    usageCount: 10000,
    scriptQuality: 9.9,
    links: diamonds.slice(0, 10).map(d => d.id), // Connect to first 10 Diamonds
    gems: [],
    tags: ['legendary', 'hub', 'nervous-system', 'diamond', 'neuron'],
    created: new Date('2024-01-01').toISOString(),
    lastUpdated: new Date().toISOString()
  };
  
  diamonds.unshift(nervousDiamond);
  
  return diamonds;
}

// Generate trading contract
function generateTradingContract(): string {
  return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * Diamond Trading Contract
 * 
 * Allows trading of Diamond contracts based on:
 * - Rarity (Common, Magic, Rare, Epic, Legendary)
 * - Community Rating (0-10)
 * - Usage Count
 * - Script Quality
 * 
 * Rarity Colors:
 * - Common: #FFFFFF (White)
 * - Magic: Blue (#4A90E2)
 * - Rare: Yellow/Gold (#FFD700)
 * - Epic: Purple (#9B59B6)
 * - Legendary: Bronze/Gold (#CD7F32)
 */

interface IDiamondTrading {
    struct DiamondListing {
        address diamondAddress;
        address seller;
        uint256 price;
        string rarity;
        uint256 rating;
        uint256 usageCount;
        bool isActive;
    }
    
    function listDiamond(address diamondAddress, uint256 price) external;
    function buyDiamond(uint256 listingId) external payable;
    function updateRating(address diamondAddress, uint256 newRating) external;
    function getDiamondInfo(address diamondAddress) external view returns (
        string memory rarity,
        uint256 rating,
        uint256 usageCount,
        string memory color
    );
}

contract DiamondTrading is IDiamondTrading {
    mapping(address => DiamondListing) public listings;
    mapping(address => uint256) public diamondRatings;
    mapping(address => uint256) public diamondUsage;
    mapping(address => string) public diamondRarity;
    mapping(address => string) public diamondColors;
    
    uint256 public listingCounter;
    DiamondListing[] public allListings;
    
    event DiamondListed(address indexed diamond, address indexed seller, uint256 price, string rarity);
    event DiamondSold(address indexed diamond, address indexed buyer, uint256 price);
    event RatingUpdated(address indexed diamond, uint256 newRating);
    
    /**
     * @dev List a Diamond for trading
     */
    function listDiamond(address diamondAddress, uint256 price) external override {
        require(price > 0, "Price must be greater than 0");
        require(!listings[diamondAddress].isActive, "Diamond already listed");
        
        listings[diamondAddress] = DiamondListing({
            diamondAddress: diamondAddress,
            seller: msg.sender,
            price: price,
            rarity: diamondRarity[diamondAddress],
            rating: diamondRatings[diamondAddress],
            usageCount: diamondUsage[diamondAddress],
            isActive: true
        });
        
        allListings.push(listings[diamondAddress]);
        listingCounter++;
        
        emit DiamondListed(diamondAddress, msg.sender, price, diamondRarity[diamondAddress]);
    }
    
    /**
     * @dev Buy a listed Diamond
     */
    function buyDiamond(uint256 listingId) external payable override {
        require(listingId < allListings.length, "Invalid listing");
        DiamondListing storage listing = allListings[listingId];
        
        require(listing.isActive, "Listing not active");
        require(msg.value >= listing.price, "Insufficient payment");
        
        listing.isActive = false;
        
        // Transfer payment to seller
        payable(listing.seller).transfer(listing.price);
        
        // Refund excess
        if (msg.value > listing.price) {
            payable(msg.sender).transfer(msg.value - listing.price);
        }
        
        emit DiamondSold(listing.diamondAddress, msg.sender, listing.price);
    }
    
    /**
     * @dev Update community rating for a Diamond
     */
    function updateRating(address diamondAddress, uint256 newRating) external override {
        require(newRating <= 10, "Rating must be <= 10");
        
        diamondRatings[diamondAddress] = newRating;
        
        // Recalculate rarity based on new rating
        uint256 usage = diamondUsage[diamondAddress];
        uint256 quality = newRating; // Simplified: quality = rating
        
        // Calculate rarity
        string memory rarity = calculateRarity(newRating, usage, quality);
        diamondRarity[diamondAddress] = rarity;
        diamondColors[diamondAddress] = getRarityColor(rarity);
        
        emit RatingUpdated(diamondAddress, newRating);
    }
    
    /**
     * @dev Get Diamond information
     */
    function getDiamondInfo(address diamondAddress) external view override returns (
        string memory rarity,
        uint256 rating,
        uint256 usageCount,
        string memory color
    ) {
        return (
            diamondRarity[diamondAddress],
            diamondRatings[diamondAddress],
            diamondUsage[diamondAddress],
            diamondColors[diamondAddress]
        );
    }
    
    /**
     * @dev Calculate rarity based on metrics
     */
    function calculateRarity(uint256 rating, uint256 usage, uint256 quality) internal pure returns (string memory) {
        uint256 normalizedUsage = usage > 1000 ? 10 : (usage * 10) / 1000;
        uint256 combinedScore = (rating * 40 + normalizedUsage * 30 + quality * 30) / 100;
        
        if (combinedScore >= 95) return "Legendary";
        if (combinedScore >= 75) return "Epic";
        if (combinedScore >= 50) return "Rare";
        if (combinedScore >= 25) return "Magic";
        return "Common";
    }
    
    /**
     * @dev Get color for rarity
     */
    function getRarityColor(string memory rarity) internal pure returns (string memory) {
        bytes memory rarityBytes = bytes(rarity);
        if (keccak256(rarityBytes) == keccak256(bytes("Legendary"))) return "#CD7F32";
        if (keccak256(rarityBytes) == keccak256(bytes("Epic"))) return "#9B59B6";
        if (keccak256(rarityBytes) == keccak256(bytes("Rare"))) return "#FFD700";
        if (keccak256(rarityBytes) == keccak256(bytes("Magic"))) return "#4A90E2";
        return "#FFFFFF";
    }
}
`;
}

// Main function
async function main() {
  console.log('ðŸŒ³ Generating Obsidian Diamond Tree...');
  console.log('='.repeat(70));
  
  const obsidianDir = '/home/theos/obsidian_vault';
  const contractsDir = '/home/theos/contracts';
  
  // Create directories
  if (!fs.existsSync(obsidianDir)) {
    fs.mkdirSync(obsidianDir, { recursive: true });
  }
  if (!fs.existsSync(contractsDir)) {
    fs.mkdirSync(contractsDir, { recursive: true });
  }
  
  // Generate Diamond nodes
  console.log('Generating Diamond nodes...');
  const diamonds = generateDiamondNodes();
  console.log(`âœ… Generated ${diamonds.length} Diamond nodes`);
  
  // Generate Obsidian markdown files
  console.log('Generating Obsidian markdown files...');
  diamonds.forEach(diamond => {
    const content = generateObsidianNode(diamond);
    const filename = `${diamond.id}.md`;
    fs.writeFileSync(`${obsidianDir}/${filename}`, content);
  });
  console.log(`âœ… Generated ${diamonds.length} Obsidian notes`);
  
  // Generate graph visualization
  console.log('Generating graph visualization...');
  const graphContent = generateGraphVisualization(diamonds);
  fs.writeFileSync(`${obsidianDir}/Diamond_Tree_Graph.md`, `# Diamond Tree Graph\n\n${graphContent}`);
  console.log('âœ… Generated graph visualization');
  
  // Generate index/overview
  const indexContent = `# Diamond Tree Index

## Overview

This is the Obsidian knowledge graph of the Diamond nervous system.
Each Diamond contract is a node, and links between them form the "tree".

## Rarity System

- **Common** (<span style="color: #FFFFFF">#FFFFFF</span>): Rating 0-2.5
- **Magic** (<span style="color: #4A90E2">Blue</span>): Rating 2.5-5.0
- **Rare** (<span style="color: #FFD700">Yellow/Gold</span>): Rating 5.0-7.5
- **Epic** (<span style="color: #9B59B6">Purple</span>): Rating 7.5-9.5
- **Legendary** (<span style="color: #CD7F32">Bronze/Gold</span>): Rating 9.5-10.0

## All Diamonds

${diamonds.map(d => `- [[${d.id}]] - <span style="color: ${d.color}">${d.rarity}</span> - â­${d.communityRating.toFixed(1)}`).join('\n')}

## Graph Visualization

See [[Diamond_Tree_Graph]] for the full network visualization.

## Trading

Diamonds can be traded based on their rarity and community rating.
See the trading contract for details.

---
*Generated: ${new Date().toISOString()}*
`;
  fs.writeFileSync(`${obsidianDir}/Index.md`, indexContent);
  console.log('âœ… Generated index');
  
  // Generate trading contract
  console.log('Generating trading contract...');
  const tradingContract = generateTradingContract();
  fs.writeFileSync(`${contractsDir}/DiamondTrading.sol`, tradingContract);
  console.log('âœ… Generated DiamondTrading.sol');
  
  // Generate manifest
  const manifest = {
    system: 'Obsidian Diamond Tree',
    concept: 'Each contract is a Diamond node in a knowledge graph',
    rarity_system: RARITY_COLORS,
    rarity_thresholds: RARITY_THRESHOLDS,
    total_diamonds: diamonds.length,
    diamonds: diamonds.map(d => ({
      id: d.id,
      name: d.name,
      address: d.address,
      rarity: d.rarity,
      color: d.color,
      rating: d.communityRating,
      usage: d.usageCount,
      quality: d.scriptQuality,
      links: d.links.length
    })),
    generated_at: new Date().toISOString()
  };
  
  fs.writeFileSync(`${obsidianDir}/manifest.json`, JSON.stringify(manifest, null, 2));
  console.log('âœ… Generated manifest');
  
  console.log('');
  console.log('='.repeat(70));
  console.log('âœ¨ Obsidian Diamond Tree Generated!');
  console.log(`   Total Diamonds: ${diamonds.length}`);
  console.log(`   Obsidian Notes: ${diamonds.length}`);
  console.log(`   Graph Visualization: âœ…`);
  console.log(`   Trading Contract: âœ…`);
  console.log('');
  console.log('ðŸŒ³ The "tree" is the link structure between Diamonds.');
  console.log('   Each Diamond is a node, connections form the nervous system.');
}

main().catch(console.error);
